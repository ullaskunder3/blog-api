---
title: >-
  Using GitHub as a Headless CMS for Blogs with Next.js â€“ and Publishing to
  dev.to + RSS!
subtitle: >-
  Learn how to build a fast, modern blog using GitHub as a content store, MDX
  for writing, Next.js for rendering, and RSS feeds to publish automatically to
  dev.to
id: 13
date: '2025-05-08'
tag:
  - nextjs
  - mdx
  - rss
  - dev.to
  - github
  - blog
  - next-api
  - ssr
  - seo
  - cms
---

# Using GitHub as a Headless CMS for Blogs with Next.js â€“ and Publishing to dev.to + RSS!

ğŸ“ GitHub â†’ ğŸ” Next.js API â†’ ğŸŒ Blog + ğŸ”— RSS â†’ âœ¨ dev.to

**TL;DR:**
We're managing blog posts with MDX files inside a GitHub repo (private for safety), pulling them into our **Next.js** app as a **read-only CMS**, rendering them dynamically with Markdown, generating an RSS feed, and publishing to platforms like **dev.to**. Clean, modern, no bloated CMS, no rebuilds on blog edits. ğŸ’¡

---

### ğŸ§ Why GitHub as a Blog CMS?

Most devs use tools like Notion, Sanity, WordPress (ew ğŸ˜¬), or even headless CMSes like Contentful. But what if I told you...

> â€œYou already have a version-controlled, Markdown-friendly, Git-powered CMS sitting in your toolbelt.â€

Thatâ€™s right: **GitHub**.

We manage all blog content as `.mdx` files in a **dedicated repo**, separate from our actual portfolio or blog frontend. Why?

#### ğŸ”¥ The Pain Point

If you include blog `.mdx` content **inside your Next.js app repo**, every time you tweak a typo, you have to:

- Push code
- Rebuild the whole app
- Redeploy

Thatâ€™s... not ideal. Especially when the blog isnâ€™t even changing the codebase.

#### ğŸ’¡ The Solution

So we decoupled it. Blog content lives in a **separate GitHub repo** (like `blog-api`) and our main blog frontend fetches blog files from it using the **GitHub API**.

Private repo? Absolutely.

> Because if itâ€™s public, some clever clowns ğŸ¤¡ might try to PR garbage or scrape it aggressively. Not today, Internet.

---

### ğŸ—‚ï¸ Blog Content Structure

Our `blog-api` repo looks like this:

```powershell
C:\dev\blog-api
|
|-- advance-javascript.mdx
|-- basic-of-react-hooks.mdx
|-- basic-of-react17.mdx
```

Each file contains frontmatter metadata at the top:

```mdx
---
title: "Advance JavaScript"
subtitle: "Exploring closures, scopes and the weird parts"
id: 001
date: "Aug 3, 2023"
tag: ["js", "closures", "advanced"]
---

Your content goes here in MDX...
```

Thatâ€™s it. Simple, readable, version-controlled.

## ğŸ”Œ Wiring It into Next.js

```cmd
C:.
â”‚   favicon.ico
â”‚   head.tsx
â”‚   Home.tsx
â”‚   layout.tsx
â”‚   loading.tsx
â”‚   manifest.ts
â”‚   not-found.tsx
â”‚   page.tsx
â”‚   robots.ts
â”‚   sitemap.ts
â”‚
â”œâ”€â”€â”€api
â”‚   â”œâ”€â”€â”€blog
â”‚   â”‚   â””â”€â”€â”€v2
â”‚   â”‚       â”‚   route.ts // GET all blog posts
â”‚   â”‚       â””â”€â”€â”€[slug]
|                  â””â”€â”€â”€route.ts // GET blog by slug
â”‚
â”œâ”€â”€â”€blogs
â”‚   â”‚   BlogClient.tsx
â”‚   â”‚   page.tsx // Blogs list page ssr
â”‚   â””â”€â”€â”€[slug]
â”‚         â””â”€â”€â”€page.tsx // Dynamic blog post page
â”‚
â”œâ”€â”€â”€rss
â”‚    â””â”€â”€â”€route.ts // RSS feed route
â”‚
â””â”€â”€â”€lib
    â”œâ”€â”€â”€assets.ts
    â”œâ”€â”€â”€dateFormater.ts
    â”œâ”€â”€â”€fetchBlogFromGithub.ts
    // Fetch all MDX posts via GitHub API
    â”œâ”€â”€â”€fetchPostFromAPI.ts
    // Fetch single post from GitHub raw
    â”œâ”€â”€â”€getBaseUrl.ts
    â”œâ”€â”€â”€getProjectsData.ts
    â”œâ”€â”€â”€mailApi.ts
    â”œâ”€â”€â”€markdownToHtml.ts
    â”œâ”€â”€â”€nodemailer.ts
    â”œâ”€â”€â”€utils.ts
    â””â”€â”€â”€getPostMetaData.ts
    // Pull metadata from all blog posts

```

Now letâ€™s break down how we make this dynamic in **Next.js** (App Router), _without_ rebuilding every time.

---

### ğŸ§  Step 1: API route to fetch all blog posts

Inside `/app/api/blog/v2/route.ts`, we add:

```ts
export const dynamic = "force-dynamic";

export async function GET() {
  const posts = await fetchBlogPostsFromGitHub();
  return NextResponse.json(posts);
}
```

Why dynamic? Because we want **on-demand rendering** with periodic revalidation, not static build-time fetches.

---

### ğŸª Step 2: `fetchBlogPostsFromGitHub()` from our GitHub repo

In `/lib/fetchBlogFromGithub.ts`:

```ts
const res = await fetch(
  `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents?ref=${BRANCH}`,
  { headers: { Authorization: `Bearer ${GITHUB_TOKEN}` } }
);

const files = await res.json();
const mdxFiles = files.filter((file) => file.name.endsWith(".mdx"));
```

We loop through each file and use [gray-matter](https://github.com/jonschlinkert/gray-matter) to parse the frontmatter:

```ts
const { data, content } = matter(rawContent);
```

That gives us metadata like `title`, `date`, and the actual blog `content`.

This returns a nice, digestible array of blog posts to the API consumer (our blog frontend).

---

### ğŸ“¦ Client-side Fetch & Rendering

In `/app/blogs/page.tsx`, we call our API:

```tsx
const posts = await getPostMetaData();
return <BlogClient posts={posts} />;
```

Inside `getPostMetaData()`:

```ts
const response = await fetch(`${BASE_URL}/api/blog/v2`);
```

Why fetch from an API instead of reading `.mdx` files directly?

- Keeps server-side data handling clean
- Allows for revalidation with `next: { revalidate: 60 }`

---

### ğŸ” View Individual Posts

In `[slug]/page.tsx`, we dynamically fetch the content:

```ts
const postContent = await fetchPostFromAPI(slug);
```

This hits:

```ts
GET / api / blog / v2 / [slug];
```

Which in turn fetches:

```ts
https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${slug}.mdx
```

We parse the raw `.mdx` again using `gray-matter`, then render it with:

```tsx
<Markdown remarkPlugins={[remarkGfm]} rehypePlugins={[rehypeRaw]}>
  {postContent.content}
</Markdown>
```

Boom. Fully dynamic blog. No build required. New blog post? Just `git push` to your content repo and youâ€™re done. ğŸ‰

## ğŸ“° Bonus: Generating an RSS Feed

RSS is still relevant â€“ especially if you want to syndicate to sites like dev.to or Feedly.

In `/app/rss/route.ts`, we:

1. Call `getPostMetaData()` again
2. Convert each post to `<item>` XML
3. Wrap everything in a valid `<rss>` schema

```xml
<rss version="2.0">
  <channel>
    <title>Ullas Kunder Blog</title>
    <link>https://ullaskunder.com</link>
    <description>...</description>
    ${items.join("")}
  </channel>
</rss>
```

Served with:

```ts
return new NextResponse(rss, {
  headers: {
    "Content-Type": "application/xml",
  },
});
```

You now have an **auto-updating RSS feed** from your GitHub-powered blog. ğŸ¤˜

Want to make sure itâ€™s valid? Use this tool from W3C:

- In **development**, use **Validate by Direct Input**
- Once deployed, use **Validate by URL**

ğŸ‘‰ [https://validator.w3.org/feed/](https://validator.w3.org/feed/)

Make sure your XML is well-formed â€” dev.to and other RSS consumers can be picky.

---

### âœï¸ Publish to dev.to via RSS

Platforms like **dev.to** can automatically sync articles from your RSS feed.

Just head to your dev.to settings â†’ **Extensions â†’ RSS Integration**, and paste your RSS feed URL (e.g., `https://yourdomain.com/rss`).

Once dev.to pulls in your post, you'll see it listed in your dashboard under **Posts**:

But hereâ€™s the catch:
ğŸš« Thereâ€™s **no visible "Publish" button** or any clear indication on that list view â€” which honestly sucks. Youâ€™d expect to be able to publish right from there, but no.

Instead, you have to **click "Edit"** on a post.
Only _inside the edit screen_ will you see the message:

> `Unpublished Post. This URL is public but secret, so share at your own discretion.` > _(Click to edit)_

Click that link, and in the editor, youâ€™ll see the synced metadata at the top:

```md
---
title: Essential React Hooks: A Comprehensive Guide
published: false
date: 2023-07-19 00:00:00 UTC
tags: react, hooks, beginners
canonical_url: https://ullaskunder.tech/blogs/basic-of-react-hooks
---
```

ğŸ‘‰ All you need to do is change:

âœ… `published: false` to `published: true`

...then save. Boom â€” itâ€™s live.

> ğŸ› ï¸ Hopefully dev.to improves this flow â€” it would be far more intuitive to allow publishing directly from the post list.

## ğŸ§  What Weâ€™ve Achieved

- âœ… Keep content and code separate
- âœ… Avoid rebuilding the blog for every new post
- âœ… Secure and version-controlled Markdown storage
- âœ… Dynamic content loading with caching
- âœ… Auto-generating RSS feed
- âœ… Easy syndication to dev.to or elsewhere

---

## ğŸ” Why a Private GitHub Repo?

Because the internet is... well, the internet.

- Public repo = free-for-all
- Random people might PR garbage
- Or worse, spam bots might crawl it constantly

So, we keep it **private** and authenticate with a **GitHub token** (stored securely via environment variables like `GITHUB_TOKEN`).

## ğŸš€ Future Enhancements

- âœï¸ Add support for content previews (e.g., `/drafts`)
- ğŸ§  Add AI summaries or highlights
- ğŸ” Integrate search indexing (Algolia, Meilisearch)
- ğŸ’Œ Generate email newsletters from RSS

## ğŸ’¬ Wrapping Up

Using GitHub as your blog CMS might feel odd at first, but it makes total sense for dev-centric blogs:

- Markdown is natural for us
- Git is already part of our workflow
- Next.js handles the rendering like a champ

> Write locally. Commit. Push. Done.
> Let your blog do the heavy lifting, not your deploy pipeline.
